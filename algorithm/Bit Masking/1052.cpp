#include <iostream>

using namespace std;

int bit_count(int bit); // bit에서 1비트 개수 구하기
int bit_delete(int bit, int n); // bit에서 1비트 n개 없애기(왼쪽부터)

int main(){
  int N, K, buy = 0;

  scanf("%d %d", &N, &K);

  if(bit_count(N) > K){
    N = bit_delete(N, K-1);

    for(int i=0; 1; i++){
      if((1<<i) >= N){
        buy = (1<<i) - N;
        break;
      }
    }
  }
  
  printf("%d", buy);

  return 0;
}

int bit_count(int bit){
  if(bit==0) return 0;
  return bit%2 + bit_count(bit/2);
}

int bit_delete(int bit, int n){
  int count = 0;

  for(int i=25; count<n; i--){
    if(bit & (1<<i)){
      bit &= ~(1<<i);
      count++;
    }
  }

  return bit;
}

/*
살짝 까다로웠던 비트마스킹 문제. 그리디 문제이기도 하다.
N이 13이라고 치자. 13을 2의 제곱수만을 이용하여 표현하면? 8+4+1 이다. 즉, 물이 처음에 1리터씩 13개 있었으면, 그 중 8개를 합치면서 8L짜리
하나로 만들 수 있고, 4개를 합쳐서 또 하나로 만들 수 있다. 이렇게 합치면 총 3병이 된다. 이때, K가 3보다 크거나 같다면? 답은 0이다. 이미
원래 갖고 있던 물병을 합치면서 3개로 줄일 수 있기 때문이다. 만약 K가 3보다 작다면? 3개보다 더 줄어야한다. 이를 위해서는, 1L짜리 물병을
4L짜리 물병과 합쳐야하므로, 1L짜리 물병 3개가 더 필요하다. 그 3개랑 원래 1개랑 합쳐서 4L를 만들고, 그걸 원래 4L짜리랑 합쳐서 개수를 줄인다.

이걸 일반화해보자. N을 2의 제곱수만을 이용하여 표현하는 것을 비트로 표현한다면? 위의 사례를 예로 들면, 13 == 1101 이 된다. 여기서 1비트의
개수를 세고, 그걸 K와 비교한다. K가 그거보다 작다면? 가장 왼쪽 1비트부터 K-1개의 1비트에 해당하는 물병은 그대로 사용할 것이고, 왼쪽부터
K번째 1비트와, 그 오른쪽의 1비트에 해당하는 물병들을 하나로 합칠 것이다. 그렇게 해야 K-1 + 1 = K개가 된다.

이것을 위해, 우선 14행에서 bit_delete 함수를 통해 가장 왼쪽부터 K-1번째 1비트를 모두 지워주었다. 만약 N이 13이고 K가 2라면, 왼쪽부터 1번째
1비트를 지워줄테니, 1101에서 0101이 된다. 그 다음으로, 0101에서 몇 개의 물병을 더 사서, 1000이 되도록 하면 된다. 0011 == 3을 더해주면 
1000 == 8이 되므로, 답은 3이다. 설명이 좀 어렵게 됐는데, 0101 이상이고 가장 작은 2의 제곱수(8)를 찾고, 거기에서 0101(5)을 빼주면 답이 된다.

bit_delete 함수에서, 37행에서 int i=25 라고 했다. bit에서 가장 왼쪽에 있는 1비트를 찾아야해서, 제일 왼쪽 칸부터 찾아야하는데, 주어지는 N이
최대 10^7 == 천만 정도라서, 2^25면 3200만 정도로 N보다는 충분히 크니까, (1<<25)로 시작하면 N의 가장 왼쪽에 있는 1비트부터 찾는 것이 반드시
보장됨. 그래서 그냥 대충 i=25로 시작했다.
*/