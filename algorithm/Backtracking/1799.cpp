#include <iostream>

using namespace std;

int N;
int left_up[19] = {0}, right_up[19] = {0};
int maximum[2] = {0, 0};
int board[10][10];

void put(int r, int c, int color, int count);

int main(){
  scanf("%d", &N);
  for(int i=0; i<N; i++)
    for(int j=0; j<N; j++)
     scanf("%d", &board[i][j]);
  
  put(0, 0, 0, 0);
  put(0, 1, 1, 0);
  
  printf("%d", maximum[0]+maximum[1]);
  return 0;
}

void put(int r, int c, int color, int count){
  if(r<N && c<N){
    if(board[r][c] && !left_up[r-c+N-1] && !right_up[r+c]){
      left_up[r-c+N-1] = 1;
      right_up[r+c] = 1;
      put(r, c+2, color, count+1);
      left_up[r-c+N-1] = 0;
      right_up[r+c] = 0;
    }
    put(r, c+2, color, count);
  }
  else if(c>=N){
    c = (c%2) ? 0 : 1;
    put(r+1, c, color, count);
  }
  else
    maximum[color] = max(maximum[color], count);
}

/*
시간초과 안 나게 짜는게 어려웠던 백트래킹 문제.
처음에는 그냥 칸을 하나하나 돌면서, "비숍을 놓고 다음 칸 탐색" / "놓았던 비숍을 빼고 다음 칸 탐색"
이런 방식으로 dfs를 돌았다. 그리고 놓을 비숍의 최대 개수를 i, 비숍을 놓을 수 있는 칸(1인 칸)의 개수를 count라고 했을 때,
i를 count부터 1까지 감소시키면서 처음으로 비숍을 i개 다 놓을 수 있게 될 때 i를 출력했다.
근데 시간초과가 뜨자, 아하 보드에 1이 뒤지게 많으면, 그거 하나하나 다 해보느라 시간초과가 나는구나 그러면 i를 1부터 증가시키면서
처음으로 다 놓을 수 없게 될 때, 그 전의 i값(i-1)을 출력해야겠다 라고 생각해서 그렇게 해봤는데 그래도 시간초과가 났다.

고민 좀 하다가 도저히 모르겠어서 다른 코드를 참고해봤는데, https://j2wooooo.tistory.com/80 여기 코드에서 도움을 많이 얻었다.

우선 좌상향/우상향 그래프의 개념을 이용하여 left_up과 right_up 배열을 사용하게 되었음. 이거는 n퀸 문제에서도 비슷하게 썼던 건데,
비숍은 대각선으로 움직일 수 있는데 이때 좌상향 대각선에 있는 칸들과는 행-열 값이 같고, 우상향에 있는 칸들과는 행+열 값이 같다.
이걸 이용해서 (r, c)라는 칸에 비숍을 놓을 수 있는지를 확인하려 할 때 해당 칸의 대각선 칸을 다 방문해볼 필요 없이,
left_up[r-c] 값과 right_up[r+c] 값을 확인해보고, 둘 다 0이면 좌상향/우상향 대각선에 비숍이 아직 없는 것이므로 놓을 수 있게 된다.
놓은 다음에는 1 넣어주면 됨. 이때 N이 10일 때 r-c값은 범위가 -9~9, r+c값은 0~18이니깐 둘 다 최대 크기는 19로 해두고, r-c값이
음수가 나오는 것을 감안하여 N-1만큼을 더해줘서 인덱스를 사용하면 된다(left_up[r-c+N-1]=1 이런 식으로).

그 다음으로, 모든 칸을 하나하나 돌지 않고 color가 0일 때와 1일 때로 나누어서 반씩 두 번 돌도록 코드를 짰다. 이게 무슨 말이냐면,
체스판에서 검정 칸에 놓인 비숍은 검정 칸에만, 흰 칸에 놓인 비숍은 흰 칸에만 갈 수 있다. 그렇기 때문에 어떠한 칸을 탐색했다면(put을 썼다면),
그 다음 칸에 put을 쓰지 않고 다다음 칸에 put을 쓴다. 이런 식으로 두 번 반복하면, 첫 번째는 (0, 0)부터 시작하여 검정 칸에만 비숍을 둘 것이고,
두 번째는 (0, 1)부터 시작하여 흰 칸에만 비숍을 둘 것이다. 그 다음 두 경우의 비숍의 최대 개수를 더하면 답이 된다. 왜냐? 어차피 각 경우의
비숍들은 서로 공격 못하기 때문에, 흰 칸에 비숍을 뭐 어디에 두든간에 검은 칸에 비숍을 두려는 것에 영향을 주지 않음.
추가 설명을 하자면, 어차피 흰 칸과 검은 칸의 비숍은 공격할 일이 뒤져도 없으니깐 그냥 아예 별개의 칸(완전 다른 보드라고 봐도 됨)으로
본다고 했을 때, (N/2)*(N/2)칸 탐색하는 걸 두 번 하게 되는 거임.
이렇게 짜면, 원래 최대 2^(10*10)이었던 시간복잡도가 2^(5*5)*2 정도로 줄어들게 된다.
*/