#include <iostream>
#define MAX 1000000

using namespace std;

long long f[MAX+1] = {0}, g[MAX+1] = {0};

int main(){
  int T;

  for(int i=1; i<=MAX; i++){
    for(int j=i; j<=MAX; j+=i)
      f[j] += i;

    g[i] = g[i-1] + f[i];
  }

  scanf("%d", &T);

  while(T--){
    int N;

    scanf("%d", &N);

    printf("%lld\n", g[N]);
  }

  return 0;
}

/*
쉬운 문제였는데 너무 어렵게 생각해서 고민했던 누적합 문제. 
f(x) = x의 모든 약수의 합. g(x) = f(1)+f(2)+...+f(x) 일 때, N이 주어질 때 g(N)을 구하면 된다(이때 N은 최대 10만 번 주어진다).

N이 최대 10만 번 주어지기에, g(N)을 O(1) 정도로 구해야 한다. 그러려면 주어질 때마다 계산하는 것이 아니라 미리 값을 채워놓아야 한다. 
이때, g(x) = g(x-1) + f(x) 이다. 그렇기 때문에, f(x)를 알 수 있다면, 어떠한 g(x)는 O(1)로 구할 수 있으니까, 모든 g(x)를 채우는 데
O(100만) 정도(주어지는 N의 최댓값이 100만이기에)가 걸리니까 굿. f(x)를 알 수 있으려면? 모든 f(x)도 다 채워놓아야 한다. 

여기서 고민을 좀 했는데, 아무리 생각해도 모든 f(x)를 채우려면, 그냥 i는 [1, 100만]일 때, i의 모든 배수의 f값에 += i를 해주는 것밖에
떠오르지 않았음. 즉 i가 1이면 f(1) += 1, f(2) += 1, ...를 해주고, i가 2면 f(2) += 2, f(4) += 2, ...를 해주는 것밖에 안 떠오름. 물론
이렇게 i는 100만일 때까지 하면 모든 f(x)를 다 채울 수는 있지만, 총 계산 횟수가 100만 + 50만 + 33만 + 25만 + ... + 1 번이니까, 시간초과가
날 줄 알았다. 근데 혹시 몰라서 테스트 해보니까, 다 채워도 프로그램이 안 터짐. 그래서 그대로 그냥 짜보니까 맞았다..

계산해보니깐 저거 횟수 다 더해도 13970034 = 대충 1400만 번밖에 안 됨. 그걸로 f(x) 채우고, g(x)는 O(100만)으로 채운 다음, 각 쿼리(N)마다
O(1)로 대답할 수 있으니 시간 초과가 안 난 것...
*/