#include <iostream>
#define MAX 500000

using namespace std;

int S[MAX+1] = {0}, J[MAX+1] = {0};

int main(){
  int N, H;

  scanf("%d %d", &N, &H);

  for(int i=1; i<=N; i++){
    int obs_h;

    scanf("%d", &obs_h);

    if(i%2) S[obs_h]++;
    else J[H+1-obs_h]++;
  }

  for(int h=H-1; h>=1; h--)
    S[h] += S[h+1];

  for(int h=2; h<=H; h++)
    J[h] += J[h-1];

  int min_obs = N+1, count = 0;

  for(int h=1; h<=H; h++){
    int obs = S[h]+J[h];

    if(obs < min_obs){
      min_obs = obs;
      count = 1;
    }
    else if(obs == min_obs)
      count++;
  }

  printf("%d %d", min_obs, count);

  return 0;
}

/*
처음에 좀 헤맸던 누적 합 문제.

높이 x일 때 부수게 되는 장애물(석순과 종유석)의 개수를 y라고 하자. y의 최솟값과, y가 최솟값인 모든 x의 개수를 구하면 된다.

개똥벌레의 높이를 i라고 잡았을 때, 부숴야하는 석순의 개수는 arr[0], arr[2], arr[4], ... 중에서 값이 i 이상인 놈들의 개수이다.
부숴야하는 종유석의 개수는? arr[1], arr[3], arr[5], ... 중에서 값이 (H+1-i) 이상인 놈들의 개수이다.
여기까지는 알았는데, 모든 i(1부터 H)에 대해서 부수는 장애물 개수를 다 구하려니 20만*50만의 경우의 수가 나와서 너무 많다.

좀 헤매다가, 다른 누적 합 문제 풀 때, 누적 합 배열(S[i]: 0번째 수~i번째 수의 합)을 채울 때 썼던 방법이 생각나서 그걸 써봤다.
우선 석순을 생각해봤을 때, 석순의 높이 h를 입력받았다고 하자. 그러면 S[h]++을 해준다(높이가 h인 석순의 개수를 S[h]에 넣기).
입력이 다 끝난 다음, S의 의미를 바꾼다. 이제 S[h]는 높이 h로 갔을 때 부수게 되는 석순의 총 개수이다. 이걸 위해, h = [H-1, 1]에 대해서, 
S[h] += S[h+1]을 해준다. 왜냐? 어떠한 높이 h로 갈 때 부수는 석순의 개수는, '높이가 딱 h인 석순의 개수 + 높이 h+1로 갈 때 부수는 석순의
개수'이기 때문이다(석순은 아래에서 위로 나있으니깐, h 초과의 높이로 갈 때 부수는 석순은 h로 갈 때도 반드시 부수게 된다). 

이걸 종유석(J) 배열에 대해서도 똑같이 해준다. 그러면, 최종적으로 S[i]: 높이 i로 갈 때 부수는 석순 개수. J[i]: 높이 i로 갈 때 부수는 종유석
개수. 가 된다. 이제 모든 높이(1부터 H)에 대해서, 제일 적은 장애물을 부술 때 그 개수와, 그런 높이의 개수를 구해주면 된다.

https://hyeo-noo.tistory.com/310 여기 풀이랑 거의 비슷했다.
*/