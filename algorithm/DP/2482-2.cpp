#include <iostream>
#define MAX 1000
#define DEN 1000000003

using namespace std;

int dp[MAX+1][MAX+1] = {0}; // dp[i][j]: 1~i번 색 중에서 j개 고르기

int main(){
  int N, K;

  scanf("%d", &N);
  scanf("%d", &K);

  for(int i=0; i<=N; i++){
    dp[i][0] = 1;
    dp[i][1] = i;
  }

  for(int i=2; i<=N; i++)
    for(int j=2; (j<=K && j<=i); j++)
      dp[i][j] = (dp[i-2][j-1] + dp[i-1][j]) % DEN; // i번 색을 고를 경우 + i번 색을 안 고를 경우

  printf("%d", (dp[N-3][K-1] + dp[N-1][K]) % DEN); // 1번 색을 고를 경우 + 1번 색을 안 고를 경우

  return 0;
}

/*
https://everenew.tistory.com/42 여기 풀이를 보고 다시 풀어보았다.
배낭 문제 풀이와 비슷하다는 느낌이 들었다. 우선, dp[i][j]: 1~i번 색 중에서 j개를 고르는 경우의 수. 이다. 참고로 이때 색은, 원형이 아니라
일렬로 되어있다고 가정한다. 우선, 색이 몇 개이든 0개를 고르는 경우는 1가지이고, 1개를 고르는 경우는 색의 개수와 같다. 이 기저 조건을 15행에서
넣어줬다. 그리고, 1~i번 색 중에서 j개를 고르는 경우는, i번 색을 고르는 경우와 안 고르는 경우로 나눌 수 있다.
i번 색을 고르는 경우는? i번 색을 골라야 하니까, i-1번은 고르지 못한다. 그러므로, 1~i-2번 색 중에서 j-1개(i번을 골랐으니까)를 고르는 경우와 같다.
i번 색을 안 고르는 경우는? i번만 안 고르면 되니까, 1~i-1번 색 중에서 j개를 고르는 경우와 같다.
전자는 dp[i-2][j-1] 이고, 후자는 dp[i-1][j] 이다. 이거를, i는 [2, N]에 대해서 반복한다(i가 0, 1일 때의 값들은 15행에서 넣어줬음). 그리고 이때 
j는, 위의 풀이에서는 j<=K 일때 다 돌려주는 식으로 했는데, 나는 j<=i 라는 조건도 달아놨다. 왜냐면, 1~i번 중에서 j개를 고르는 건데, j가 i를
넘어가면 어차피 0이니까 볼 필요 없을 것 같아서.. 근데 어차피 7행에서 0으로 다 초기화해놔서 답은 똑같이 나옴.

어쨌든 여기서 끝내고, dp[N][K]를 출력해버리면 틀린다. 왜냐? dp배열에서 가정한 색은, 원형이 아니라 일렬이기 때문. 그래서, 1번 색을 고를 경우를 또
따져줘야 한다(1번 색은 원형일 때는 N번 색과 같이 못 고르지만, 일렬일 때는 같이 고를 수 있기 때문).
1번 색을 고른다면? 1번, 2번, N번을 제외한 색 중에서 K-1개를 골라주면 된다. 그렇기에, 일렬로 된 N-3개의 색 중에서 K-1개를 고르는 경우와 같고,
이것은 dp[N-3][K-1]과 같아진다. 
1번 색을 안 고른다면? 1번을 제외한 색 중에서 K개를 골라주면 된다. 이것은 dp[N-1][K]와 같아진다.
두 값 더하고, 나머지 연산 잘 해주고 출력하면 맞음.

dp문제 풀 때 나는 주로 DP라는 함수 정의하면서 재귀식으로 많이 푸는데, 이렇게 bottom-up 방식으로도 많이 해봐야 할듯.. 그리고 냅색 문제처럼
i값을 하나하나 증가시키면서 하는 뭐 그런 느낌의 풀이도 해봐야 함.
*/