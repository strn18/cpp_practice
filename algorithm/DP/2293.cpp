#include <iostream>

using namespace std;

int main(){
  int n, k;
  int c[100], DP[10001] = {0};
  scanf("%d %d", &n, &k);
  for(int i=0; i<n; i++)
    scanf("%d", &c[i]);

  DP[0] = 1;
  for(int i=0; i<n; i++)
    for(int j=c[i]; j<=k; j++)
      DP[j] = DP[j]+DP[j-c[i]];
  
  printf("%d", DP[k]);

  return 0;
}

/*
오랜만에 풀어본 DP문제. 근데 점화식 찾기가 꽤 힘들었다. 처음에는 dp[i][j][k]: i원을 만들 때 j번째 동전을 k개 쓸 때의 경우의 수
로 세웠는데, k가 0이 아닐 때는 dp[i][j][k] = dp[i-c[j]*k][j][0] 라는 식이 나오지만 k가 0일 때는 두 식이 똑같아져서 값을 도출해내기 어려웠다.
그래서 포기하고, 두 번째로는 dp[i][j]: i원을 만들 때 동전을 j개 사용했을 때 경우의 수
로 세워서 dp[i][j] = dp[i-c[0]][j-1] + dp[i-c[1]][j-1] + ... 인가 생각했는데 이러면 동전의 조합은 같고 순서만 다른 경우들이 중복으로 카운트되어서
dp[i][j]의 값이 커져버린다.. 그래서 포기

고민하다가 모르겠어서 https://yabmoons.tistory.com/491 여기 풀이를 참고했는데 생각보다 간단했다.. dp 테이블을 여러 번 갱신하는 방법으로 풀었다.
dp[i]: i원을 만드는 경우의 수로 두고, 우선 dp[0]만 1로 하고 나머지 테이블은 0으로 둔다. 그 다음 i는 [0, n)일 때 c[i]를 돌면서, 그 안에서 다시
j는 [c[i], k]일 때 dp[j] = dp[j]+dp[j-c[i]]라는 점화식이 성립된다. 왜냐하면, 우변에서 dp[j]는 c[i] 동전을 사용하지 않을 때 j원을 만드는 경우
(i가 현재 값이 되기 전, 이미 조합되어있던 경우)의 수이고, dp[j-c[i]]는 c[i] 동전을 하나는 무조건 사용한다치고, j-c[i]원을 만드는 경우의 수이다.

여기서 "왜 c[i] 동전을 두 개 이상 사용한 경우는 더하지 않지?" 라는 생각이 들었는데, 어차피 j-c[i]원을 만드는 경우의 수(=dp[j-c[i]]) 안에
c[i]를 0개 이상 사용해서 j-c[i]원을 만드는 경우들이 모두 포함되어있기 때문에, 위에서 c[i] 동전을 최소 하나는 사용한다친다고 했으니깐
dp[j-c[i]]만 더해주면 c[i]를 1개 이상 사용해서 j-c[i]원을 만드는 경우의 수(당연히 2개 이상 사용한 경우도 포함)를 더하게 되는 것이다. 

말이 좀 복잡한데, "j는 [c[i], k]일 때"라는 for문을 돌면서, j가 현재 값인 j가 되기 전, j-c[i]일 때, 그 때도 점화식이 성립되어서 dp[j-c[i]]라는
dp 테이블이 "c[i] 동전을 0개 이상 사용했을 때 j-c[i]원을 만드는 경우의 수"로 갱신되게 된다. 그렇기 때문에, j가 현재값인 j가 되었을 때,
dp[j] = dp[j]+dp[j-c[i]]라는 점화식 안에서, 오른쪽의 dp[j-c[i]]는 아까 말했던 "c[i] 동전을 0개 이상 사용했을 때 j-c[i]원을 만드는 경우의 수"를
담당하게 되고, 그 경우들에 c[i]원을 각각 더한다고 치면 그 경우들은 "c[i] 동전을 0+1개 이상 사용했을 때 j-c[i]+c[i]원을 만드는 경우들"이
되는 것이다. 그리고 왼쪽의 dp[j]는, dp[j-c[i]]와 달리 아직 갱신이 안 됐으니까, "c[i] 동전을 사용하지 않았을 때 j원을 만드는 경우의 수"를 담당하게
되고, 이 둘을 더하면 "c[i] 동전을 1개 이상 사용했을 때 j원을 만드는 경우의 수"+"c[i] 동전을 0개 사용했을 때 j원을 만드는 경우의 수"가 되니까,
"c[i] 동전을 0개 이상 사용했을 때 j원을 만드는 경우의 수"가 되어, dp[j]를 갱신하게 된다. 이후 j나 i가 커졌을 때, 그 때의 점화식에 이 값을 
사용하게 된다. 아까 위에서 (아직 갱신 안 된)dp[j]와 (갱신 된)dp[j-c[i]]를 사용했던 것처럼..

설명이 ㅈㄴ 복잡해졌는데 솔직히 문제 풀 때도 이해하기 힘들었다.. DP 문제를 오랜만에 풀어서 그런 건지는 모르겠는데 어쨌든 DP 강의 들으면서 
다시 한 번 쭉 공부해봐야할듯
*/