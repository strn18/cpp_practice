#include <iostream>

using namespace std;

int comb[30][30] = {0};

int combination(int n, int r){
  // return nCr

  if(comb[n][r]) return comb[n][r];

  if(n == r) return comb[n][r] = 1;
  if(r == 1) return comb[n][r] = n;

  return comb[n][r] = combination(n-1, r-1) + combination(n-1, r);
}

int main(){
  int T;

  scanf("%d", &T);

  while(T--){
    int N, M;

    scanf("%d %d", &N, &M);

    printf("%d\n", combination(M, N));
  }

  return 0;
}

/*
은근 헷갈렸던 문제. MCN(M콤비네이션N)을 구하기만 하면 되는데, 좀 헷갈렸다. 이리저리 찾아보다가 nCr = n-1Cr-1 + n-1Cr 이라는 공식을 보고, 그걸
재귀함수로 구현했다. 근데 시간초과가 났는데, 처음에는 왜 나는지 몰랐는데 생각해보니까 같은 aCb가 여러 번 호출이 되어서, 피보나치 수열 함수 
그거처럼 계산이 너무 많아져서 시간초과가 난듯. 그래서 메모이제이션을 쓰니까 맞았다.

https://codejin.tistory.com/m/172 여기 풀이를 보니까 콤비네이션을 좀 신기하게 구현했다. 위의 공식으로 재귀함수를 만든 게 아니라, 그냥 곱하는
과정 그대로 구현했는데, 가령 7C4 라고 하면 우선 answer(초깃값 1)에 7을 곱하고, 1로 나눠준다. 그 다음, 6을 곱하고 2로 나눠준다. 그 다음, 5를
곱하고 3으로 나눠준다. 그 다음, 4를 곱하고 4로 나눠준다. 즉, 흔히 콤비네이션 계산할 때 쓰는 방식대로 7*6*5*4 / 4*3*2*1 을 차례대로 수행한 것. 
근데 나눠주는 수를 4부터 안 하고 1부터 한 이유는? 4부터 하면, 7 / 4 가 되어버려서, 딱 나눠떨어지지 않아서 값이 틀리게 됨. 그래서 나누는 수는
1부터 한 것. 그렇게 하면 무조건 나눠떨어지는데, 왜냐하면 이번에 나누는 수가 n이라고 하자. 그러면 곱하는 수는 지금까지 총 n개를 곱했을 것이다.
그러면 그 n개의 수 안에, n의 배수가 반드시 하나는 존재한다. 뭔 소리냐면, 위의 예시에서 이번에 나누는 수가 3이라고 하자. 그러면, 지금까지
곱하는 수는 총 3개를 곱했을 것이다(7, 6, 5). 이때, 이 세 수 안에는 반드시 3의 배수(6)가 존재한다(자연수를 차례대로 나열하면, n의 배수는 n개의
수마다 하나씩 존재하니까). 그러므로 3으로 나눴을 때 나머지가 절대 안 남음. 그렇기 때문에 1부터 나눴을 때 제대로 값을 구할 수 있는 것.
*/