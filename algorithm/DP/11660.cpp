#include <iostream>

using namespace std;

int board[1025][1025] = {0}; // index is 1-based
int dp[1025][1025] = {0}; // dp[i][j]: 1행 1열~j열 + 2행 1열~j열 + ... + i행 1열~j열 합

int Rect_sum(int x1, int y1, int x2, int y2); // (x1, y1)부터 (x2, y2)까지 합

int main(){
  int N, M, x1, y1, x2, y2;
  scanf("%d %d", &N, &M);

  for(int i=1; i<=N; i++){
    for(int j=1; j<=N; j++){
      scanf("%d", &board[i][j]);
      dp[i][j] = dp[i-1][j] + (dp[i][j-1]-dp[i-1][j-1]) + board[i][j];
      // 상단 직사각형 + (좌측 직사각형-좌상단 직사각형) + 현재 칸
    }
  }

  for(int i=0; i<M; i++){
    scanf("%d %d %d %d", &x1, &y1, &x2, &y2);
    printf("%d\n", Rect_sum(x1, y1, x2, y2));
  }

  return 0;
}

int Rect_sum(int x1, int y1, int x2, int y2){
  return dp[x2][y2] - dp[x2][y1-1] - (dp[x1-1][y2]-dp[x1-1][y1-1]);
}

/*
간단한 문제지만 N과 M이 커서, 연산 횟수를 줄이는 게 중요했던 문제.

처음에는 (x1, y1)부터 (x2, y2)까지의 합을 다 dp로 저장해야하나 싶었으나, 그러려면 dp테이블이 4차원이 되는데,
한 차원당 1024의 크기를 가지는지라, 그렇게 짜면 배열 크기가 ㅈㄴ커짐. 그래서 폐기.

그 다음에는 dp[i][j]: i행에서, 1열~j열까지의 합. 이라고 두는 걸 생각해봤는데, 이건 dp테이블 크기가 100만 정도로 괜찮지만
이걸 가지고 구간 합 구하는 걸 M번 하려면, 최대 1024행까지 있으니까 한 번당 약 1024번 연산을 하게 되고, 그걸 최대 10만 번(M)을 하게 되니까
10만*1024 = 약 1억 번의 연산(O(N*M))을 하게 된다. 대충 1초=1억이라고 치면 많이 초과하는 건 아니지만, 아마 시간초과가 나게 될 것이다. 

그 다음에는 위에서 한 차원 더 크게 생각해서, dp[i][j]: 1행의 1열~j열 + 2행의 1열~j열 + ... + i행의 1열~j열로 두었다. 이렇게 되면 dp테이블
크기는 그대로 100만 정도이고, 이걸로 구간 합 구하는걸 10만 번 한다면, 한 번당 약 한 번(O(1)) 정도의 연산(dp테이블이 다 채워져 있다면, 코드의
Rect_sum 함수에서 했던 것처럼 dp값을 잘 이용하면 채워진 dp값만 받아서 계산 후 리턴하면 된다)이 드니까 총 10만 번 정도의 연산(O(M))이면 
문제를 풀 수 있다. 이후에는 메인 함수에서 dp테이블 잘 채워주고, Rect_sum 함수 잘 짜기만 하면 되었다.

그리 어려운 문제는 아니었으나, dp테이블의 크기와 내용 설정이 중요한 것을 배울 수 있었음.
*/