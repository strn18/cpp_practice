#include <iostream>

using namespace std;

int main(){
  int N, total = 0;
  int dp[1001][10] = {0}; // dp[i][j]: 길이가 i이고, 맨 앞자리 수가 j인 오르막 수의 개수
  
  scanf("%d", &N);
  
  for(int j=0; j<10; j++)
    dp[1][j] = 1;
    
  for(int i=2; i<=N; i++){
    for(int j=0; j<10; j++){
      for(int k=j; k<10; k++)
        dp[i][j] += dp[i-1][k];

      dp[i][j] %= 10007;
    }
  }

  for(int j=0; j<10; j++)
    total += dp[N][j];

  printf("%d", total%10007);

  return 0;
}

/*
점화식 찾는 게 어렵지 않았으나 어이없는 부분에서 시간초과 났던 문제..

우선, 처음에는 dp[i]: 길이가 i인 오르막 수의 개수. d[i][j]: 길이가 i이고, 맨 앞자리 수가 j인 오르막 수의 개수. 로 둔 다음,
d[i][0] = dp[i-1], d[i][1] = dp[i-1]-(d[i-1][0]), ..., d[i][9] = dp[i-1]-(d[i-1][0]+...+d[i-1][8]) 인 것을 이용하여 점화식을 세워서 답은
잘 나왔으나, 쓸데없이 복잡해진데다가 10007로 나머지 연산 해줘야하는데 과정이 귀찮아져서 d와 dp를 하나로 통합하고 점화식도 바꿨다.

dp[i][j]: 길이가 i이고, 맨 앞자리 수가 j인 오르막 수의 개수. 로 둔 다음,
dp[i][0] = dp[i-1][0]+...+dp[i-1][9], dp[i][1] = dp[i-1][1]+...+dp[i-1][9], ..., dp[i][9] = dp[i-1][9] 로 식을 간소화하여, 점화식은
dp[i][j] = dp[i-1][j]+...+dp[i-1][9] 가 되었다. 그리고 '어떠한 수들의 합을 n으로 나눈 나머지'는 '그 어떠한 수들 각각을 n으로 나눈 나머지의 합을
n으로 나눈 나머지'와 같다는 점을 이용하여, dp테이블을 채운 후 10007로 나머지 연산을 해준 다음 마지막 total 값도 10007 나머지 연산을 해주었다.

이렇게 해서 분명 답이 잘 나오는데 제출하니까 틀렸다고 떴다. 처음에는 나머지 연산 하는 과정에서 값이 달라지는 부분이 있었나 싶어서, 지금 코드에
N=15를 넣었을 때의 값과 나머지 연산을 하기 전 코드에 N=15를 넣었을 때의 값을 10007로 나눈 나머지 값을 비교했는데 다른 부분은 없었다;;
그래서 씨발 머지 왜틀리지?? 싶어서 여기저기 살펴봤는데도 틀린 부분은 없었다. 그러다가 7행에서 dp 배열을 초기화하지 않고 선언만 한 것을 보고,
아 설마 vscode 컴파일러랑 백준 컴파일러랑 뭐 방식이 좀 달라서, 여기서는 초기화 안 해도 문제 안 생기는데 백준에서는 문제가 생기나? 싶어서
지금 코드대로 초기화해준 다음에 제출했더니 맞았다고 떴다. 
*/