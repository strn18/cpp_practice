#include <iostream>

using namespace std;

int main(){
  int N;
  int dp[31] = {0};

  scanf("%d", &N);
  
  dp[0] = 1;
  dp[2] = 3;

  for(int i=3; i<=N; i++){
    if(i%2) continue;

    dp[i] += dp[i-2]*dp[2];

    for(int j=4; i-j>=0; j+=2)
      dp[i] += (dp[i-j]*2);
  }
  
  printf("%d", dp[N]);

  return 0;
}

/*
2*n 타일링 문제와 비슷하지만, 변형이 되어서 난이도는 높아진 dp문제. 2*n이 아니라 3*n 타일링이라서, 삐죽 튀어나온 모양이 존재하게 된다. 
그렇기 때문에, dp[i]: 3*i 크기의 타일을 채우는 경우의 수. 일 때, 2*n 타일링에서처럼 단순하게 점화식을 세울 수는 없었다.

우선 dp[0] = 1(아무것도 안 놓는 경우), dp[2] = 3(직접 세봄)이고, dp[홀수]는 0이다. 왜냐하면, i가 홀수이면 3*i도 홀수인데, 놓을 수 있는 타일은
1*2와 2*1밖에 없어서, 짝수밖에 못 놓는다. 그래서 dp[홀수]라면 타일을 빈 칸 없이 채울 수 없다. 그래서 0이다.

그 다음, dp[4]를 생각해보면, 경우는 두 가지로 나눌 수 있다. 1) 2번째 경계선(3*2 타일의 우측 경계선)에서, 경계선을 넘지 않고 채우기.
2) 2번째 경계선을 넘고 채우기. 1)은 dp[2]*dp[2]이다. 걍 왼쪽 3*2와 오른쪽 3*2를 채우는 경우의 수를 곱하면 됨. 2)는 2가지이다. 왜냐하면,
△◁▷△          ◁▷◁▷ 
▽◁▷▽ 이거랑   ▽◁▷▽ 이거 밖에 없음. 우선 경계선들 한 칸이나 세 칸이 넘을 수는 없다. 한 칸이 넘으면, 오른쪽 3*2로 한 칸만 넘어가니까,
◁▷◁▷          △◁▷△                오른쪽은 총 5칸이 되고, 홀수니까 못 채운다. 세 칸도 마찬가지로, 오른쪽 3*2로 세 칸이 넘어가니까,
   ㅣ(2번째 경계선들)ㅣ                   오른쪽이 총 3칸이 되어서 못 채운다.
   ㅣ               ㅣ
그렇기 때문에, 1)이 9가지, 2)가 2가지로 총 11가지이다.

dp[6]은 어떨까? 1) 오른쪽에서 2번째 경계선(3*4와 3*2를 나누는 경계선. 걍 앞으로 경계선 2라고 하겠음)을 넘지 않고 채우기. 2) 경계선 2를
넘고, 경계선 4는 안 넘고 채우기. 3) 경계선 2와 4를 모두 넘고 채우기. 1)은 dp[4]*dp[2]이다. 2)는 dp[2]*2이다. 왜냐면, 아까 말했던 것처럼
경계썬 2를 넘는 경우는 2가지이고, 그거에 좌측의 3*2를 채우는 경우를 곱해줘야 하기 때문. 3)은 2이다. 이것도 그림을 그려보면 알겠지만,
경계선 4를 넘는 경우가 2가지인데, 거기서 경계선 2도 넘으려면 어차피 각각 하나밖에 안 나옴. 그래서 두 가지인데, 이걸 dp[0]*2로 표현할 수 
있겠다.

정리해보면, i가 짝수일 때 dp[i] = dp[i-2]*dp[2] + (dp[i-4]*2 + dp[i-6]*2 + ... + dp[0]*2)이다.
좀 까다로웠고, 처음에는 경계선을 넘는 경우 다 따지면 너무 많은거 아닌가? 싶었으나, 잘 따져보니까 두 가지씩밖에 안 나오는 걸 확인할 수
있었고, 이를 통해 점화식을 세울 수 있었음.
*/