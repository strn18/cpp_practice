#include <iostream>
#define MAX 200

using namespace std;

int main(){
  int N, longest = 0;
  int kids[MAX+1], dp[MAX+1];

  scanf("%d", &N);
  for(int i=1; i<=N; i++)
    scanf("%d", &kids[i]);
  
  dp[1] = 1;
  for(int i=2; i<=N; i++){
    dp[i] = 0;
    for(int j=1; j<i; j++)
      if(kids[j] < kids[i] && dp[j] > dp[i])
        dp[i] = dp[j];
    dp[i]++;
  }

  for(int i=1; i<=N; i++)
    longest = max(longest, dp[i]);
  
  printf("%d", N-longest);

  return 0;
}

/*
좀 어려워보여서 고민을 했는데, 알고보니 쉬웠던 문제. 
어떠한 수열(1~N으로 이루어짐)이 주어졌을 때, 이를 오름차순 정렬하기 위해 몇 개의 수를 옮겨야하는지 구하면 된다.
처음에는 어떠한 수를 왼쪽 or 오른쪽으로 옮길 때, 몇 개의 수를 제낄 수 있는지(왼쪽으로 옮기는 거면, 어떠한 수보다 큰 수들을 얼마나 제끼게 되는지)
같은 것을 세면서, 하나하나 옮겨보는 방식으로 했는데, 제출해보니 두 번 다 틀렸다.. 

그래서 좀 고민을 했었는데, 생각해보니까 매우 쉬운 문제였다. 우선, 길이가 N인 수열이 있을 때, 이 수열을 정렬하기 위해 최대로 많은 수를 옮길 경우,
몇 개를 옮기게 되고, 이때 수열은 어떤 상태일까? 당연히 N, N-1, ..., 1의 형태로 내림차순 형태이고, 이때 N-1개를 옮겨야한다.
그 다음으로 최악은? N, N-1, ..., 2, 3, 1과 같이, 딱 두 개의 수가 정렬되어있고 나머지는 내림차순인 형태이고, 이때 N-2개를 옮겨야한다.
그 이유는? 2와 3은 정렬되어있고, 나머지 수만 2와 3을 기준으로 잘 옮겨주면 된다.
이걸 일반화하면, 어떠한 부분수열이 정렬되어있을 때, 그 길이가 s라고 하자. 주어진 수열에서 최대의 s를 찾는다면, 답은 N-s가 되지 않을까?
예를 들어 수열이 4 1 5 2 3 이라고 하자. 이때, 1과 5가 정렬되어있고, 2와 3이 정렬되어있다. 그러므로, s의 최댓값은 2이고, 답은 5-2 = 3번이 된다.

문제가 좀 꼬아놔서 그렇지, 결국 가장 긴 증가하는 부분수열을 찾는 문제였음. 즉 11053번 문제랑 사실상 똑같은 문제임..
dp[i]: i번째 수를 포함할 때, i번째 수까지의 가장 긴 증가하는 부분 수열의 길이. 라고 잡으면,
dp[i] = max(j는 [0, i)에서, kids[j] < kids[i]일 때, dp[j]) + 1. 로 점화식이 세워진다. 제출하니 맞았음. 
*/