#include <iostream>
#include <string.h>
#define MAX 1000
#define DEN 1000000003

using namespace std;

int dp[MAX+1][MAX+1];

int DP(int i, int j);

int main(){
  int N, K, ans = 0;

  scanf("%d", &N);
  scanf("%d", &K);

  memset(dp, -1, (MAX+1)*(MAX+1)*sizeof(int));

  if(K==1)
    ans = N;
  else{
    if(N-3 >= K-1) ans += DP(N-3, K-1);
    for(int i=N-3; i>=K-1; i--){
      ans += DP(i, K-1);
      ans %= DEN;
    }
  }

  printf("%d", ans);  

  return 0;
}

int DP(int i, int j){
  if(dp[i][j] != -1) return dp[i][j];

  if(j==0){
    dp[i][j] = 1;
  }
  else if(j==1){
    dp[i][j] = i;
  }
  else{
    dp[i][j] = 0;
    for(int k=2; i-k>=j-1; k++){
      dp[i][j] += DP(i-k, j-1);
      dp[i][j] %= DEN;
    }
  }

  return dp[i][j];
}

/*
쪼금 어려웠던 dp문제. 우선 나는 dp[i][j] = i개의 색이 일렬로 있을 때, 그 중 j개를 연속되지 않게 고르는 경우의 수. 로 잡았다. 이때 i개의 색은
색상환처럼 시작과 끝이 연결된 원 모양이 아니라 일렬로 있다고 했는데, 왜냐하면 어떠한 색상환에서 우선 색 하나를 고르면, 그 앞뒤 색은 못 고르게
되니까, 나머지 색들은 원 모양으로 연결되어있지 않다. 자세한 건 22행에서 설명..

dp를 저렇게 잡으면, 우선 K가 1일 때는 답은 당연히 N이다. K가 1이 아닐 때, 답은 dp[N-3][K-1] + dp[N-3][K-1] + dp[N-4][K-1] + ... + dp[K-1][K-1]
이다. 왜냐? 우선 N이 6, K가 3이라고 하면, 우선 처음에 1번 색을 고른다. 그러면 1번과 인접한 6, 2번도 못 고르므로, 나머지 두 개의 색은 3, 4, 5번
중에서 골라야한다. 그러므로 경우의 수는 dp[3][2]가 된다. 그 다음, 처음에 2번 색을 고르면, 1, 3번을 못 고르므로, 마찬가지로 dp[3][2]이다.
처음에 3번 색을 고르면, 2, 4번을 못 고르고 1번도 못 고르므로(맨 처음에 따졌으니까), dp[2][2]이다. 

그리고 dp 점화식은 다음과 같다. dp[i][j] = dp[i-2][j-1] + dp[i-3][j-1] + ... + dp[j-1][j-1] 이다. 아까 ans에 대한 공식은 첫 항이 dp[N-3][K-1]
이었는데, dp 점화식에서는 dp[i-2][j-1]이다. 이것만 빼면 둘이 같은데, 이게 다른 이유는? ans는 원 모양 색상환이었기에, 1번을 고르면 2번은 물론이고
N번도 못 고른다. 하지만 dp에서는, 색이 일렬로 있을 때니까 1번을 고르면 2번만 못 고른다(N번은 고를 수 있다). 그러므로 첫 항이 달라진 것.

그 부분만 제외하면 둘이 거의 같고, 이것 외에 dp 배열의 base condition만 잘 체크해주면 되었다. 

근데 다른 풀이 보니까 시간이 훨씬 짧던데 왜 그런지는 잘 모르겠다. 어차피 최대 1001*1001 정도인 dp 배열 채우는 방식이라는 건 비슷하지 않나??
*/