#include <iostream>
#include <vector>
#define MAX 1000000

using namespace std;

vector<int> edge[MAX+1];
int dp[MAX+1][2];
bool visited[MAX+1] = {false};

void dfs(int i);

int main(){
  int N, u, v;

  scanf("%d", &N);

  for(int i=0; i<N-1; i++){
    scanf("%d %d", &u, &v);
    edge[u].push_back(v);
    edge[v].push_back(u);
  }

  dfs(1);

  printf("%d", min(dp[1][0], dp[1][1]));

  return 0;
}

void dfs(int i){
  visited[i] = true;
  dp[i][0] = 0;
  dp[i][1] = 1;

  for(int idx=0; idx<edge[i].size(); idx++){
    int child = edge[i][idx];    
    if(visited[child]) continue;

    dfs(child);
    dp[i][0] += dp[child][1];
    dp[i][1] += min(dp[child][0], dp[child][1]);
  }
}

/*
점화식 찾는 것이 어려웠던 dp문제. 처음에는 dp[i]: i명이 얼리어답터일 때, 아이디어를 수용한 사람 수의 최댓값. 등등 이런저런 dp테이블을 생각해봤으나
모르겠어서 포기. 그 다음에는 그냥 dp 말고 트리를 이리저리 탐색하는 방식을 생각해보았다.

그 결과, 주어진 간선들을 통해 노드들을 트리 구조로 표현했을 때, 리프 노드를 자식으로 가진 노드들을 제거하고, 그 다음에 또 리프 노드를 자식으로
새로이 가지게 된 노드들을 제거하고... 를 반복하여 모든 노드가 제거될 때까지 count하여 그 수가 답이라는 것을 생각해냈다.
근데 문제는, 트리의 노드들 중 '리프 노드를 자식으로 가지는 노드'들을 찾는 과정이 O(n)이라서, 최종 시간복잡도는 O(n^2) 정도가 되는데 n이 백만이라
시간초과가 날 것이라 생각했다. 그래서 이거는 O(n)으로 풀어야겠구나 라고 생각을 해서, 처음에 위에서 아래로 탐색하며 노드들의 depth를 파악하고, 
밑에서부터 차례차례 올라오며 노드들을 지워나가야하나? 싶었는데 어떻게 해야할지 모르겠어서 고민하다가, 다른 코드를 참조했다.

https://conkjh032.tistory.com/372 여기 글에서 많이 도움을 받았다. 우선 내가 생각했던 것처럼 노드들을 트리 관계로 놓았다고 치고,
dp[i][0]: i번 노드가 일반인일 때, 그 밑의 노드들이 모두 아이디어를 수용하게 하는 얼리어답터 수의 최솟값. 이고,
dp[i][1]: i번 노드가 얼리어답터일 때, // 로 두었다.
그 다음 맨 위의 노드(1번 노드라 하겠음. 몇 번 노드든 상관없다 어차피 트리 구조 나오니깐)에서부터 dfs를 하여, 자식 노드들의 dp값을 갱신시키고,
그걸 통해 본인의 dp값을 갱신시키며 올라가서 1번 노드의 dp값을 갱신시킨다. 마지막에, dp[1][0]과 dp[1][1] 중 작은 값을 출력하면 된다.

dp[i][0]은, i번 노드의 밑에 있는 자식 노드들이 모두 얼리어답터여야하니깐, 0에다가 dp[child][1]을 모두 더해주면 된다(사실 i번 노드가 
아이디어를 수용하려면 그 위에 있는 연결되어있는 노드(부모 노드)도 얼리어답터이어야하지만, 지금 dp테이블은 밑에서부터 부분적으로 재귀적으로
보니깐 그건 상관없다.). 즉, dp[i][0] = dp[child][1]의 합.
dp[i][1]은, i번 노드 밑의 자식 노드들이 얼리어답터이든 아니든 상관없다. 근데 i번 노드는 무조건 얼리어답터니깐 1만 더해주면 된다. 즉,
dp[i][1] = min(dp[child][0], dp[child][1])의 합+1.

이걸 통해, dp값을 갱신시켜주는 함수인 dfs를 만들고, dfs(i)가 호출되면 i의 자식노드들에대해 dfs를 해주면서 그 dp값을 갱신시켜주고, 그걸로
i의 dp값을 갱신시키면 된다. 이때, i와 연결된 노드들 중 부모노드에 대해서는 dfs를 또 해주면 안 되니깐, visited 배열을 만들어서 방문체크를
해준다.

답을 알게되니 쉬웠지만, 점화식 찾는게 매우 어려웠다..
*/