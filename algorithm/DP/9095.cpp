#include <iostream>

using namespace std;

int ans[11]={1, 1, 2};
int solve(int n);

int main(){
  int T;
  scanf("%d", &T);
  for(int i=0; i<T; i++){
    int n;
    scanf("%d", &n);
    printf("%d\n", solve(n));
  }
  return 0;
}

int solve(int n){
  if(!ans[n])
    ans[n] = solve(n-1)+solve(n-2)+solve(n-3);
  return ans[n];
}

/*
쉬운 DP문제. top-down(재귀) 방식으로 풀었다. 사실 조금만 풀어보면 n을 1, 2, 3으로 표현하는 방법의 수는 n-1, n-2, n-3의 각 방법의 수를 합친 것과
같다는 건 쉽게 도출할 수 있다. 그래서 쉽게 풀었는데 한동안 왜 그런지는 몰랐음. 근데 생각해보니, 가령 n=5일 때,
5를 1, 2, 3의 합으로 표현하는 방법 중 가장 오른쪽에 1이 오는 경우는 4를 1, 2, 3의 합으로 표현한 방법의 오른쪽에 +1을 추가한 것이다.
예를 들어 1+3이라는 식 오른쪽에 +1을 붙인 1+3+1은 5를 1, 2, 3의 합으로 표현하는 방법 중 가장 오른쪽에 1이 오는 경우에 해당된다.
마찬가지로 5를 1, 2, 3의 합으로 표현하는 방법 중 가장 오른쪽에 2가 오는 경우는 3을 1, 2, 3의 합으로 표현한 방법의 오른쪽에 +2를 붙인 것이고,
가장 오른쪽에 3이 오는 경우는 2를 1, 2, 3의 합으로 표현한 방법의 오른쪽에 +3을 붙인 것이다.
이 세 가지 경우(오른쪽에 1, 2, 3이 오는 경우)를 모두 합치면 그것이 곧 5를 1, 2, 3의 합으로 표현하는 방법이 된다.
그렇기 때문에 n을 1, 2, 3으로 표현하는 방법의 수는 n-1, n-2, n-3일 때의 각 방법의 수를 합친 것과 같아지는 것.
*/