#include <iostream>
#include <math.h>
#include <string.h>
#define INF 2147483647

using namespace std;

int N, maxV;
int W[17][17]; // W[i][j]: i에서 j로 가는 비용(i, j는 1 based)
int dp[17][65536]; // dp[i][info]: info를 이진수로 표현했을 때, 값이 0인 인덱스는 방문을 안 한 것. 이때, i에서 그 인덱스 노드들을 거쳐서
// 1로 돌아가는 최소 비용. ex) N = 8이고 info = 0001 1001일 때, dp[4][info]: 1, 4, 5를 방문했을 때, 4에서 시작하여 2, 3, 6, 7, 8를 거쳐서 
// 1로 돌아가는 최소 비용.

int DP(int from, int info); // dp값이 있으면(0 또는 양수일 때) 리턴하고, 없으면(-1일 때) 찾아서 리턴한다.

int main(){
  scanf("%d", &N);
  maxV = pow(2, N)-1; // 함수 DP의 인자인 info의 최대 크기
  
  for(int i=1; i<=N; i++)
    for(int j=1; j<=N; j++)
      scanf("%d", &W[i][j]);
  
  memset(dp, -1, 17*65536*sizeof(int)); // dp를 모두 -1로 초기화시켜준다.

  printf("%d", DP(1, 1)); // info = 0000 0000 0000 0001(1만 방문했을 때, 1에서 나머지 노드를 방문하고 1로 가는 최소 비용)

  return 0;
}

int DP(int from, int info){
  if(dp[from][info] == -1){ // 아직 dp값이 없을 때
    if(info == maxV){ // 만약 모든 노드를 방문하여 info의 비트가 모두 1이 되었다면, 모든 노드를 방문했으니 1로 돌아가는 비용만 구한다.
      dp[from][info] = W[from][1];
      return dp[from][info];
    }

    dp[from][info] = INF;

    for(int i=2; i<=N; i++){
      if(info & (1<<(i-1))) continue; // i가 방문한 노드라면 패스
      // i는 방문 안 한 노드
      int new_info = info | (1<<(i-1)); // info에서 i를 방문했다고 처리한 것을 new_info로 둔다.
      if(W[from][i] && DP(i, new_info)) // from에서 i로 갈 수 있고, i에서 남은 노드들을 거쳐 1로 돌아갈 수 있다면
        dp[from][info] = min(dp[from][info], W[from][i]+DP(i, new_info)); // dp값을 갱신해준다(최솟값으로).
    }

    if(dp[from][info] == INF) // from에서 방문 안 한 노드들을 거쳐 1로 돌아갈 수 있는 경우가 없다면 dp값은 0이다.
      dp[from][info] = 0;
  }

  return dp[from][info];
}

/*
백트래킹으로 풀었던 10971과 똑같은 외판원 순회 문제이지만, N이 최대 16이라서, 백트래킹으로 풀면 15!가지 경우를 모두 계산해야 하기 때문에 시간초과가
날 것이다. 그렇기에, dp를 통해 중복 계산을 하지 않도록 줄여줘야 한다. 가령, N = 8 이고 집합 s = {5, 6, 7, 8} 일 때, 1에서 출발하여 1-2-3-4 순으로
방문한 후, 남은 {5, 6, 7, 8}노드를 거쳐서 다시 1로 돌아가는 최소 비용을 계산해놓았다면, 1-3-2-4 순으로 방문을 했을 때, 또다시 남은 {5, 6, 7, 8}
노드를 거쳐서 다시 1로 돌아가는 최소 비용을 또 계산할 필요가 없다. 왜냐하면, {5, 6, 7, 8}을 방문하지 않았을 때, 4에서 그것들을 방문한 후 1로 
돌아가는 최소 비용을 앞에서 계산해놓았기 때문이다. 이 점에 주목하여, 노드 방문 정보를 info라고 뒀을 때, dp[i][info]: i에서 info의 방문 안 한
노드를 거쳐 1로 돌아가는 최소 비용. 이라고 두고 풀면 된다.
이때 편의성과 메모리 효율을 위해 노드 방문 정보인 info를 비트마스킹을 통해 구현했다. info = 0011 1001 1011 0001 이라면, 맨 오른쪽부터
시작해서 i번째 노드가 1이면 방문, 0이면 방문 안 한 것이다. 즉, info는 1, 5, 6, 8, 9, 12, 13, 14번째 노드를 방문한 것임.
만약 비트마스킹을 안 쓴다면 int info[16] = {1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0} 뭐 이런 식으로 배열을 쓸 수 있는데, 복잡하고 
귀찮아보임.
비트마스킹 관련해서 https://rebro.kr/63 여기를 참조했다.
*/