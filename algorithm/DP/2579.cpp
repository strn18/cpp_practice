#include <iostream>

using namespace std;

int main(){
  int n;
  int s[301], dp[301];
  
  scanf("%d", &n);
  for(int i=1; i<=n; i++)
    scanf("%d", &s[i]);
  
  dp[0] = 0;
  for(int i=1; i<=2; i++)
    dp[i] = dp[i-1]+s[i];
  for(int i=3; i<=n; i++)
    dp[i] = max(dp[i-2]+s[i], dp[i-3]+s[i-1]+s[i]);
  
  printf("%d", dp[n]);

  return 0;
}

/*
실3따리 별로 안 어려운 문젠데 이상하게 많이 어려웠던 문제.
처음에는 3연속으로 먹으면 안 된다는 조건이 있길래, streak이라는 int 변수를 사용했다. dp 테이블을 1부터 n까지 채워주는 과정에서, 만약 이전까지
지금까지 streak이 2 미만이면 dp[i] = dp[i-1]+s[i]이고, streak이 2면 max(dp[i-1], dp[i-2]+s[i], dp[i-3]+s[i-1]+s[i]) 이런 식으로 점화식을
좀 복잡하게 세웠다(dp[i]: i번째 계단까지의 최대 점수). 그리고 dp[i]가 i번째 계단을 밟는다는 보장이 없기에, n까지 dp 테이블을 채워준 후 
streak값을 보고 1이나 2면 dp[n]을 출력하고, 0이면 다시 그 전 dp값을 보고 어쩌고저쩌고 하는 부분이 있었다. 예제는 다 맞길래 제출했는데 틀렸고,
실3따리가 왜이리 복잡하지? 하면서 고민했는데 모르겠어서 https://yabmoons.tistory.com/20 여기 풀이를 봤다.

dp[i]: i번째 계단을 밟을 때, 거기까지의 최대 점수. 로 두고, dp[i] = max(dp[i-2]+s[i], dp[i-3]+s[i-1]+s[i]) 이런 식으로 점화식도 간단하게
나왔다. 사실 i번째 계단을 밟을 때 최대 점수면, i-1번째 계단과 i-2번째 계단을 둘 다 밟을 수는 없고, 둘 다 안 밟을 수도 없으니까(최소 하나는
밟아야 최대 점수임) 1) i-2번째 계단만 밟을때, 2) i-1번째 계단만 밟을 때. 이 두가지만 보면 되는데, streak 같은 변수를 쓰면서 너무 복잡하게
생각한듯. 1)은 dp[i-2]+s[i] 이고, 2)는 i-1번째 계단만 밟고 i-2번째는 밟으면 안 되니까, i-3번째를 밟아야 규칙에 맞는다. 그렇기에 
dp[i-3]+s[i-1]+s[i]이다. 

다음부터는 dp를 풀 때 너무 복잡하게 생각하려 하지 말고 좀 띵킹을 잘 해야할듯
*/