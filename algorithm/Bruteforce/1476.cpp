#include <iostream>

using namespace std;

int main(){
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);

  int E, S, M, ans = 1;

  cin >> E >> S >> M;

  E %= 15; S %= 28; M %= 19;

  while(true){
    if((ans % 15 == E) && (ans % 28 == S) && (ans % 19 == M)) break;
    ans++;
  }

  cout << ans;

  return 0;
}

/*
걍 브루트포스로 풀면 되는 문제. E, S, M = 1, 2, 3이라고 하자. 그러면, 연도를 (a, b, c)라고 할 때, a가 1이 되는 해는 우리가 알고 있는 
연도로 했을 때 1, 16, 31, ... 년이고, b가 2가 되는 해는 2, 30, 58, ... 년, c가 3이 되는 해는 3, 22, 41, ... 년이다.
이 연도들의 최소공배수를 구하면 됨. 다시 말해, 어떠한 연도(우리가 알고 있는 방식으로 했을 때) year가 있다고 하자. 이때,
year%15 == E, year%28 == S, year%19 == M 이라면, year가 정답임. 그러면 이 year를 어떻게 구할까?
첨에는 뭔가 방법이 따로 있을 줄 알았는데, 딱히 아이디어가 안 떠올라서 그냥 브루트포스로 풀었음. year를 1부터 1씩 계속 증가시키면서,
15 28 19로 나머지 연산을 해서 E S M이 나오면 year가 답인 걸로. 근데 제출하니까 틀림. 왜 그런가 하고 봤더니, year가 15 or 28 or 19의
배수이면, 나머지 연산의 결과가 0이 나옴. 근데 E S M은 각각 1~15, 1~28, 1~19니깐 둘이 아다리가 안 맞음. 즉 그래서 E S M이 15 28 19일 때는
걍 0으로 바꿔버리고 시작하는 걸로 바꿨다(13행). 그랬더지 맞았음.
*/