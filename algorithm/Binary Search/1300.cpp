#include <iostream>

using namespace std;

int N, k;

long long count_less_than(int n);

int main(){
  int start, end;
  long long ans;

  scanf("%d %d", &N, &k);

  start = 1, end = k; // B[k] <= k
  
  while(start <= end){
    int mid = (start+end)/2;

    if(count_less_than(mid) < k){
      ans = mid;
      start = mid+1;
    }
    else
      end = mid-1;
  }

  printf("%d", ans);

  return 0;
}

long long count_less_than(int n){
  long long count = 0;

  for(int i=1; i<=N; i++)
    count += min(N, (n-1)/i);

  return count;
}

/*
어려웠던 매개변수 탐색 문제. 

가장 단순히 생각하면, N*N 배열을 1차원 배열로써 sort한 다음 k번째를 출력하면 되지만, N이 최대 10만이라 시간초과가 난다.

그래서 그동안 공부하던 매개변수 탐색 방식으로 풀어보려 했는데, 2110에서 한 것처럼 우선 문제를 뒤집어보려고(결정 문제로 바꾸려고) 해봤다.

주어진 문제는 다음과 같다. "N*N 배열에서, k번째 수는 무엇인가?".
처음에는 이걸 뒤집어서, "n이라는 수가 있을 때, n은 k번째 수 이상인가?"로 바꿔서 생각해보았다. 이렇게 하면 결정 문제(yes or no)로 바뀌고,
n이 start~end의 범위 내에서 NooooYesss 꼴이 되기는 해서 매개변수 탐색 풀이 방식에 부합하기는 함. 근데 문제는, 결국 n이 k번째 수 이상인지
아닌지 판단해야 하는데, 그걸 판단하려면 k번째 수가 뭔지를 알아야 한다. 근데 애초에 k번째 수가 뭔지 아는 것이 문제이기 때문에, 결국 뒤집기만
했지 의미가 없어짐.

그래서 한참 고민하다가, 방식을 좀 더 바꿔봤다. "n이라는 수가 있을 때, N*N 배열에서 n보다 작은 수의 개수는 k 미만인가?" 로 바꿔서 생각해봤다.
이렇게 했더니 풀기가 수월해짐. 가령, N*N 배열에서 n보다 작은 수의 개수가 c라고 하자. 이때 c가 k 미만이라면, 답은 n 이상일 것이다. 만약 c가
k 이상이라면, 답은 n 미만이다. 왜냐? 예를 들어 N이 3이고, k는 7이라고 하면, N*N 배열은 다음과 같다.
1 2 3
2 4 6
3 6 9
여기서 n=5로 잡았다고 치자. 그러면 c는 6이다. 이때 c<k 이므로, 답은 n 이상임(즉, 우선 답을 n으로 두고, 다음 번 이분 탐색 때는 start = mid+1
로 갱신하고 다시 돌려보면 됨. 자세한 건 후술). 만약 n=8이라면? c는 8이다. c>k 이므로, 답은 n 미만이다.

이 방식을 토대로, count_less_than 함수를 정의했다. 이 함수는 인자로 n을 받아서, N*N 배열에서 n보다 작은 수의 개수를 반환한다. n보다 작은
수의 개수를 세는 방법은 36행에 있는데, N*N 배열의 i행에는 i*1, i*2, i*3..., i*N이 있다. 이때 이 i행에 n보다 작은 수의 개수가 몇 개인지
세려면, min(N, (n-1)/i)를 구하면 된다. 왜냐? (n-1)/i는 n-1 이하인 수의 개수와 같다. 가령 6행이 6, 12, 18, ... 이고 n이 13일 때, 13 미만인
수의 개수는 12 이하인 수의 개수와 같은데, 이는 곧 12/6 = 2 이다. 이때 N과의 min 연산을 해주는 이유는, i행의 모든 값이 n 미만일 때는 반드시
N개이기 때문임. 이거 안 하면 (n-1)/i 값이 N보다 커져버린다. 

이 count_less_than함수를 이용하여 이분탐색을 해주면 된다. start와 end의 초기값은 각각 1과 k이다. 왜 end의 초기값이 k냐면, N*N 배열의 k번째
수는 반드시 k 이하이기 때문이다. 왜냐? 예를 들어, N*N 배열에 어떠한 p라는 수가 있다고 하자. 이 p는, 1~N 사이의 두 수의 곱꼴일 것이다. 즉,
p = p/a * a 로 표현할 수 있고, N*N 배열에서 p/a행 a열 또는 a행 p/a열에 있을 것이다. 이때 p는 몇 번째 수일까? 정확하게는 모르겠지만, 아무리
앞에 있어봐야 p번째 보다는 앞에 있을 수 없다. 즉 적어도 p번째이다. 왜냐? 오른차순 정렬을 한다면 p 앞에 반드시 (p/a * a)-1개의 수가 있기 때문임.

예를 들어 설명하자면, A[2][4]=8이다. 이때 8은 몇 번째 수일까? 잘은 모르겠으나, 최소한 A[1][1], A[1][2], ..., A[1][4], A[2][1], ..., A[2][3]
보다는 뒤에 있다. 즉, 8 앞에 최소한 (2 * 4)-1개의 수가 있는 것임. 이를 일반화하면, p라는 수는 q>=0일 때 반드시 p+q번째이다. 그러므로,
k번째 수는 반드시 k 이하라고 할 수 있다. 그렇기에 end의 초기값이 k인 거임.

이 start와 end값을 갖고, 이분탐색을 해주면 된다. 만약 count_less_than(mid)가 k 미만이라면, mid 미만인 수가 k개 미만인 것으로, 답은 mid이거나
그 초과가 된다. 그러므로 우선 ans = mid로 해주고, start = mid+1로 갱신해준다. 만약 k 이상이라면, mid 미만인 수가 k개 이상이다. 그러므로
mid는 답이 되지 못하고, end = mid-1로 갱신해준다. 
*/