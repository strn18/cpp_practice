#include <iostream>
#include <algorithm>

using namespace std;

bool Compare(int a, int b){
  return a>b;
}

int main(){
  int C[50], F[10000];
  int use[50] = {0};
  int N, M, low_use_idx;

  scanf("%d", &N);
  for(int i=0; i<N; i++)
    scanf("%d", &C[i]);
  
  scanf("%d", &M);
  for(int i=0; i<M; i++)
    scanf("%d", &F[i]);

  sort(C, C+N, Compare);
  sort(F, F+M, Compare);

  if(F[0]>C[0]){
    printf("-1");
    return 0;
  }

  for(int i=0; i<M; i++){
    low_use_idx = 0;

    for(int j=0; j<N; j++){
      if(F[i] > C[j]) break;

      if(use[low_use_idx] > use[j])
        low_use_idx = j;
    }

    use[low_use_idx]++;
  }
  
  int ans = -1;
  for(int i=0; i<N; i++)
    if(use[i] > ans)
      ans = use[i];
  
  printf("%d", ans);
  
  return 0;
}

/*
처음에 살짝 헤맸지만 어렵지 않게 풀었던 그리디 문제.

처음에는, 우선 크레인은 int형 배열, 화물은 int형 큐에 넣고 크레인과 화물을 내림차순 정렬한다. 그 다음, 크레인을 돌고, 그 안에서 화물을 돌면서, 
만약 화물.front를 옮길 수 있다면 pop하며 이번 턴에 옮기고, 다음 크레인으로 넘어간다. 만약 옮길 수 없다면, 다음 크레인들도 옮길 수 없으므로, 
턴(출력값)을 하나 증가시킨다. 이렇게 짰는데, 사실 여기엔 오류가 있다. 만약 크레인이 22 10 10 이고, 화물이 20 20 20 9 9 라면, 첫 턴에 22 크레인이 
20 화물을 옮기고, 두 개의 10 크레인이 각각 9 화물을 옮겨야한다. 그리고 두번째 턴과 세번째 턴에 22 크레인이 20 화물을 하나씩 옮겨야하므로, 
답은 3이 된다. 하지만, 내가 짰던 풀이는, 첫 턴에 22 크레인이 20 화물을 pop해서 옮기게 되고, 그 다음 10 크레인은 20 화물을 보게 되는데, 옮길 수
없으므로 다음 턴으로 넘어가버린다. 9 화물까지 봐야하는데..

그래서, 이걸 해결하기 위해 front 값만 보는 큐가 아니라 벡터로 짜서, 옮길 수 있는 화물을 볼 때까지 화물을 돌고, 발견하면 erase로 지워줘야하나?
싶었는데, 그렇게하면 시간복잡도가 50(크레인 돌기) * 10000(화물 돌기) * 10000(화물 erase 시켜주기) 가 되어버려서, 시간초과가 날 것이라 생각했다.

그래서 고민하다가, 방법을 좀 바꿔봤다. 크레인을 사용하는 횟수를 저장하는 use 배열을 만들고, use[i] = j라면, i번째 크레인을 총 j번 사용하게 되는
것이다. 그리고, 화물을 돌면서, 그 화물을 옮길 수 있는 크레인 중에서 지금까지 사용횟수가 가장 적은 크레인을 사용하면 된다. 이렇게 한 다음, 마지막에
use 배열의 값 중 최댓값을 정답으로 출력하면 된다(0번 크레인을 2회, 1번 크레인을 1회, 2번 크레인을 3회 썼다면 총 3초가 걸린다). 이게 정답이 될 수
있는 이유는, 화물과 크레인을 내림차순으로 정렬할 거니까, 이번 화물이 쓸 수 있는 크레인은 다음 화물도 무조건 쓸 수 있기 때문임(만약 0번 화물이
0, 1번 크레인을 쓸 수 있고, 1번 화물이 0번 크레인을 쓸 수 있다고 치자. 그러면, 0번 화물이 0번 크레인을 써버린다면, 1번 화물도 0번 크레인을 쓰게
되어 2초가 걸리게 된다. 하지만 실제로 답은 0번 화물이 1번, 1번 화물이 0번 크레인을 씀으로써 1초가 걸려야함. 이런 경우에는 내 풀이를 적용할 수 
없다. 하지만 이번 문제는 i번 화물이 쓸 수 있는 크레인은 i+1번 화물도 반드시 쓸 수 있기 때문에 풀이 적용 가능).

문제 맞힌 다음에 다른 사람들 풀이를 봤는데, 대부분 내가 두번째로 고려해봤던 풀이(벡터 사용)로 풀었음. 몇몇 채점 결과는 시간이 좀 걸렸던 걸 보니까
실행 시간이 좀 더 걸리는 건 맞는 것 같은데, 왜 시간초과가 안 나는지 모르겠다.
*/