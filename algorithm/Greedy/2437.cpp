#include <iostream>
#include <algorithm>

using namespace std;

int main(){
  int N, end = 0;
  int W[1000];

  scanf("%d", &N);

  for(int i=0; i<N; i++)
    scanf("%d", &W[i]);

  sort(W, W+N);

  for(int i=0; i<N; i++){
    if(W[i] <= end+1)
      end += W[i];
    else
      break;
  }

  printf("%d", end+1);

  return 0;
}

/*
좀 헤맸지만, 한 번 감 잡으니까 쉽게 풀었던 문제. 
처음에는, 브루트포스로 푸는 방법밖에 안 떠올랐다. 측정할 수 있는 무게를 벡터에 넣고, 벡터가 오름차순으로 정렬되어있을 때 끝에서부터(큰 무게부터)
무게 0까지 훑으면서, (어떠한 추의 무게+벡터 원소의 무게) 값을 벡터에 새로 추가하는 것. 근데 이거는 시간도 오래 걸리고(확실하지 않은데 약 2^N?),
벡터에 같은 무게가 중복해서 들어가지 않도록 배열(어떠한 무게가 벡터에 있다면 1)도 써야하는데, 최대 무게가 100만*1000 = 10억이라 불가능함.

도대체 어떻게 푸는 건지 모르겠어서 고민하다가, 그리디 알고리즘의 정의에 대한 이런저런 글들을 읽었음. 그 중에서,
https://hanamon.kr/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%83%90%EC%9A%95%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-greedy-algorithm/
여기에서 '탐욕 알고리즘은 말 그대로 선택의 순간마다 당장 눈앞에 보이는 최적의 상황만을 쫓아 최종적인 해답에 도달하는 방법이다'라는 말을 읽고
살짝 감을 잡은듯. 

그동안은 추의 무게를 넣은 배열인 W를 정렬하지 않고 생각했었다. 근데 그거를 오름차순으로 정렬해놨다고 생각하면, 0이상 end이하의 무게를 모두
만들 수 있다고 할 때, W[i]가 새로 들어온다면 0+W[i]이상 end+W[i]이하를 새로 모두 만들 수 있다. 근데 이때 두 구간(0이상 end이하와 0+W[i]이상
end+W[i]이하)이 연결되지 않는다면, 도중에 빵꾸가 있는 거고, 그 부분의 무게는 못 만드는 것임. 여기서, W는 오름차순으로 정렬되어있다고 했으니까,
W[i]로 그 부분의 무게를 못 만들게 되었다면, W[i+1], W[i+2], ..., W[N-1]로도 모두 못 만든다. 그러므로 답은 그 부분에서 제일 작은 무게가 됨.

예를 들어 설명하면, W가 (1, 1, 2, 6, 7)일 때, 처음에는 (0, 0)만 만들 수 있다. W[0] = 1이 들어오면, (1, 1)을 만들 수 있게 되니까 결국 (0, 1)을
만들 수 있게 됨. W[1] = 1이 들어오면, (1, 2)를 만들 수 있게 되니까 (0, 2)를 만들 수 있게 됨. 마찬가지로 W[2] = 2가 들어오면 (0, 4) 가능.
그러다가 W[3] = 6가 들어오면, (6, 10)을 새로 만들 수 있게 되는데, 이때 (0, 4)와 (6, 10) 사이에 5가 있고, 5는 못 만들게 됨. 이 5는 그 다음
W[4] = 7로도 당연히 못 만든다. 그렇기에 답은 5가 됨.

무지성으로 풀려고 하지 말고 띵킹 좀 해야된다..
*/