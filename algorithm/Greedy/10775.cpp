#include <iostream>
#define MAX 100000

using namespace std;

int parent[MAX+1]; // parent[i]: i의 부모 노드

int find_root(int u); // u의 루트 노드를 찾는다.
void union_root(int u, int v); // v의 루트 노드를 u의 루트 노드로 바꾼다.

int main(){
  int G, P, count = 0;
  bool close_flag = false;

  scanf("%d", &G);
  for(int i=0; i<=G; i++)
    parent[i] = i;

  scanf("%d", &P);

  for(int i=0; i<P; i++){
    int g, root_g;
    scanf("%d", &g);
    root_g = find_root(g);

    if(root_g == 0)
      close_flag = true;
    
    if(!close_flag){
      union_root(root_g-1, root_g);
      count++;
    }
  }

  printf("%d", count);

  return 0;
}

int find_root(int u){
  if(parent[u] == u)
    return u;

  return parent[u] = find_root(parent[u]);
}

void union_root(int u, int v){
  int root_u = find_root(u);
  int root_v = find_root(v);

  parent[root_v] = root_u;
}

/*
꽤 어려웠던 그리디 문제. 사실 맨 처음에 풀이법 떠올리는 것 자체는 어렵지 않았다.
g를 받고, g번~1번의 게이트 중 빈 게이트 중에서 번호가 가장 큰 게이트에 비행기를 도킹한다. 도킹한 게이트는 채워졌다는 걸 체크해준다.
의사 코드로는 다음과 같다.

close_flag = false;
for(P번)
  scanf(g);

  if(close_flag)
    continue;

  for(i는 [g, 1])
    if(!is_used[i])
      is_used[i] = true;
      count++;
      break;

  if(i==0)
    close_flag = true;

1번 게이트까지 다 훑었는데 빈 게이트가 없을 경우, flag를 세우고, 다음 입력부터는 무시한다.

근데 이 코드의 문제는, g번부터 1번까지 훑는 것을 총 P번 반복하는데, g가 최대 10^5 이고 P도 최대 10^5 라서, O(gP) = O(100억) 정도로 매우 커진다.

그래서 이런저런 방법들을 많이 생각해봤는데, 아무리 생각해봐도 1~n 인덱스의 배열 중에서 값이 false이고 인덱스는 최대인 놈을 O(1)이나 O(logn)으로
찾는 건 알 수가 없었다.. 이진탐색을 쓸까 생각해봤는데, 배열 값이 true와 false로 섞여있을 때 false가 있는 쪽으로 반띵 나눠가며 이진 탐색을 
해야하는데, 그걸 어케해?

그래서 결국 알고리즘 분류를 봤는데 분리 집합이라는 것이 있었음. 분리 집합에 대해서는 아래 글들을 참고했다(특히 위의 글).
https://velog.io/@mu1616/%EB%B6%84%EB%A6%AC%EC%A7%91%ED%95%A9Disjoint-set
https://sojeong-lululala.tistory.com/81
처음에는 이걸 어따 쓰나? 싶었는데, 좀 생각해보니까 알 것 같았다. 아까 이것저것 생각해보면서, 재귀함수 방식으로 아래와 같은 것도 생각해봤었는데
그거랑 비슷하다는 느낌이 크게 들었다. 재귀함수 방식은 다음과 같다.

int func(int g): 비행기 g가 도킹할 게이트의 번호를 리턴. 으로 정의해두고, 만약 g가 처음 호출되었다면 그대로 g를 리턴하면 되고, 그렇지 않다면
return func(g-1); 이렇게 g-1을 인자로 준 func을 다시 리턴해준다. 이렇게하면, 예를 들어 입력으로 7 7 7 7이 주어졌다고 하자. 그러면,
처음에는 7이 처음 들어왔으니까 그대로 7을 리턴한다. 그 다음에는, 7이 처음 온 게 아니니까 func(6)을 리턴하는데, 이때 6은 처음 왔으니까 6을 
리턴한다. 세번째에는, func(7)은 func(6)을 리턴하는데, 이때는 6이 처음 온 게 아니니까 func(5)를 리턴하고, 걔는 5를 그대로 리턴한다.
네번째에는, func(7) -> func(6) -> func(5)를 리턴하는데, 역시 5가 처음 온게 아니니까 func(4)를 리턴하고, 걔는 4를 그대로 리턴한다.
이렇게 재귀함수 방식도 생각해봤는데, 사실 이 방식도 결국 처음 떠올린 방식과 크게 다를 바가 없다. 어차피 func(g)가 호출되면, 
func(g-1) -> func(g-2) -> ... 이런 식으로 1번 ~ g번의 연산을 하게 되고, 그걸 P번 해야하니까 결국 근사적으로 O(gP)인 건 다를 바가 없음.

그래서 걍 버렸었는데, 분리 집합 방식이 이와 유사하다.
분리 집합은 i번 노드가 속한 집합을 분류하는 방식인데, 이때 어느 집합에 속하느냐는 i번 노드의 루트 노드가 누구인가로 갈린다.
즉, 1번 노드의 부모가 2번 노드이고, 2번 노드의 부모가 3번, 3번 노드의 부모가 자기자신이라면 1, 2, 3번 노드는 한 집합에 분류되는 것임.
그리고, A번 노드를 루트로 둔 집합(집합 A라고 함)과 B번 노드를 루트로 둔 집합(집합 B)을 합치고 싶다면, A번 노드의 부모를 자기자신이 아니라
B번 노드로 두면 된다(또는 그 반대로, B번 노드의 부모를 A번 노드로 둔다). 이렇게 하면 집합 A의 노드들의 루트는 B번 노드가 되면서, 같은 집합에
속하게 된다.

이 방식을 이용한다면, 우선 1번 ~ G번 노드의 부모를 모두 자기자신으로 두도록 초기화한다.
그 다음, g를 입력받는다. 이번 비행기를 넣을 게이트는 g번 노드의 루트 노드이고, 그 노드를 r이라고 한다면, r의 부모는 이제 r 자신이 아니라
r-1번 노드의 루트 노드가 되도록 바꿔준다. 다시 말해, r이 소속된 집합과 r-1이 소속된 집합을 합치는 것이다.

좀 복잡한데, 예시를 통해 설명하면 다음과 같다. 입력이 7 7 7 7 들어왔다고 치면, 우선 맨 처음에는 7번 노드의 루트는 7이니까, 게이트 7에
비행기를 넣는다. 그러고 나서, 7번 노드의 부모는 이제 자기자신이 아니라 6번 노드의 루트로 바꿔준다. 6번 노드의 루트는 자기자신이니까,
7번 노드의 부모(이자 루트)는 6번 노드가 된다. 두번째로, 7번 노드의 루트는 6이니까, 게이트 6에 비행기를 넣는다. 그리고 이제 6번 노드의
부모는 5번 노드의 부모(=5번 노드)가 된다. 세번째로, 7번 노드의 루토는 5니까 게이트 5에 비행기를 넣고, 5번 노드의 부모는 4번 노드가 된다.
마지막으로 한 번 더 하면, 최종적으로 7, 6, 5, 4번 게이트에 비행기가 들어갔고, 7, 6, 5, 4번 노드의 루트는 모두 3번 노드가 된다.

핵심은, 어떠한 집합의 루트 노드 = 그 집합의 노드들 중 번호가 가장 작은 노드. 라고 두고, g를 받았을 때 g번 노드가 소속된 집합의 루트 노드가
r이면, r번 게이트에 비행기를 넣어야 한다. 그리고, r은 이제 찼으니까 r-1번 노드의 집합에 합쳐줘야한다.

분리 집합 첫번째 링크에서, 최적화를 위해 rank를 쓰면서 높이가 낮은 집합을 높은 집합에 합쳐주도록 하는 부분이 있는데, 이 문제에 그걸 적용하면
꼬여버림(집합에서 번호가 최소인 노드가 루트 노드여야 하는데 그게 깨짐). 그래서 그 부분은 빼고, find를 최적화하는 부분만 넣고 제출했더니
맞았다.

분리 집합(union과 find)은 크게 어려운 개념은 아니고, 문제 풀이도 크게 어렵지는 않은데 설명하니까 ㅈㄴ 어려워보이네..
어쨌든 분리 집합 안 찾아봤으면 뒤져도 못 풀 문제였다.
*/