N
10: 9876543210 -> 1
11: 89876543210, 10123456789, 98765432101 -> 3
12: 789876543210, 989876543210, 898765432101, 210123456789, 101234567898, 898765432101 ?, 987654321012, 987654321010 -> 7

4321
4 321 -> 432 321
43 21 -> 4323 21


0~4.
N
5: 43210
0) x
1) 위의 것들 중 1로 시작하는 것 뒤에 수를 하나 붙이든가, 아니면 2로 시작하는 거 앞에 1을 붙이든가
2) 위의 것들 중 2로 시작하는 것 뒤에 수를 하나 붙이든가, 아니면 1 or 3으로 시작하는 거 앞에 2를 붙이든가
3) // 3 start 뒤 하나 add, 2 or 4 start 앞 2 add
->
0)
1) ?
2)
3) 343210
4) 432101
6: 343210, 432101, 101234,
7: 2343210, 2101234, 3432101, 4343210, 4321012, 1012343, 

   not start 0 / start 0
5: 43210 / 01234 -> 1/1개
0) 012343 / 1) 101234 / 2) / 3) 343210 / 4) 432101

6: 101234, 343210, 432101 / 012343 -> 3/1개
0) 0101234, 0123434, 0123432 / 1) 1012343, 1012343 ? / 2) 2101234, 2343210 / 3) 3432101, 3432101 ? 4) 4343210, 4321010, 4321012 /

7: 7/3개
0) 01012343, 01234343, 01234323, 01234321, 01012343, 01012343 4개
1) 10101234, 10123434, 10123432, 10123434, 10123432, 12101234, 12343210 5개
2) 21012343, 21012343, 23432101, 23432101 3개
3) 32101234, 32343210, 34321012, 34321010, 34343210, 34321010, 34321012 5개
4) 43432101, 43432101, 43210101, 43210123, 43210121 4개

8: 17/4개





dp[i][j]: i로 시작하는 j자리 계단 수 개수
dp[1][11] -> 10123456789
dp[1][12] -> 101234567898 
남의꺼 앞에다만 붙일래?
dp[9][11] -> 9 8765432101 이거 때문에 안 됨. 8765432101은 0~9가 다 없어. 그래서 dp[8][10]에 없을 거임. 근데 앞에 9를 붙인 98765432101은 0~9가 다 있음. 그래서 dp[9][11]에 있어야함. 근데 남의 꺼 앞에다만 붙인다고 하면 98765432101 이걸 못 만듦. 
내꺼 뒤에 붙이기, 남의꺼 앞에 붙이기
// !!! 여기부터가 중요 !!!
남의 꺼 앞에다 붙이기만 하면 중복은 안 생긴다.
근데 0이나 9(양 끝)는 남의 꺼 앞에다가 붙이기만 하면 문제 생겨. 왜냐? 위에서 보여준 것처럼,
0이나 9가 붙기 전에는 0~9가 다 없는데 얘네가 붙으면서 0~9가 다 있게될 수도 있어서.
근데 0이나 9 말고 1~8은? 붙기 전에는 0~9가 없는데 붙으면서 있게될 수 있어?
-> x
그렇다면 1~8은 남의 꺼 앞에다 붙이기만 하면 될듯?
dp[i][j]: i자리, j로 시작.
dp[10]: [0]: 1, [9]: 1
dp[11]: [1]: 1, [8]: 1, 
j가 1~8이라면, dp[i][j] = dp[i-1][j-1]+dp[i-1][j+1];
j가 0 or 9라면? 
dp[11][0]: 01234567898 얘는 어디서 나왔을까? 1~9로만 이루어진 계단 수에서, 자리가 10자리고 1로 시작하는 놈한테 0 붙인거자나. 그러면 1~9로만 이루어진 계단 수를 dp2라고 하자.
dp[i][0]: dp2[i-1][1]+dp[i-1][1];
그러면
dp[11][9]: 98765432101 얘도 똑같이, 0~8로만 이루어진 계단 수를 dp3이라고 하면,
dp[i][9]: dp3[i-1][8]+dp[i-1][8];
dp[i][j]: i자리이고, j로 시작하는, 0~9로 이루어진 계단 수.
0 < j < 9: dp[i][j] = dp[i-1][j-1]+dp[i-1][j+1];
j == 0: dp[i][j] = dp_right[i-1][1][1]+dp[i-1][j+1];
j == 9: dp[i][j] = dp_left[i-1][8][8]+dp[i-1][j-1];
dp_right[i][j][k]: i자리이고, j로 시작하는, k~9로 이루어진 계단 수.
k< j < 9: dp_right[i][j][k] = dp_right[i-1][j-1][k]+dp_right[i-1][j+1][k];
j == k: dp_right[i][j][k] = dp_right[i-1][k+1][k+1]+dp_right[i-1][k+1][k];
j == 9: dp_right[i][j][k] = 
dp_left[i][j][k]: i자리이고, j로 시작하는, 0~k로 이루어진 계단 수.

dp[left][right][i][j]: i자리이고 j로 시작하는, left~right로 이루어진 계단 수의 개수.
left < j < right: dp[left][right][i][j] = dp[left][right][i-1][j-1] + dp[left][right][i-1][j+1];
j == left: dp[left][right][i][j] = dp[left+1][right][i-1][j+1] + dp[left][right][i-1][j+1];
j == right: dp[left][right][i][j] = dp[left][right-1][i-1][j-1] + dp[left][right][i-1][j-1];
// 여기는 코드가 뱉은 답이 맞나 검사해본거(딱히 볼 필요는 x)
dp[0][4][8][1] = 7???
dp[0][4][7][0] + dp[0][4][7][2] =
dp[1][4][6][1] + dp[0][4][6][1] + dp[0][4][6][1] + dp[0][4][6][3] =
dp[2][4][5][2] + dp[1][4][5][2] + dp[0][4][5][0] + dp[0][4][5][2] + dp[0][4][5][0] + dp[0][4][5][2] + dp[0][4][5][2] + dp[0][4][5][4] =
dp[2][4][5][2] + dp[1][4][5][2] + 1 + 0 + 1 + 0 + 0 + 1 =
dp[3][4][4][3] + dp[2][4][4][3] + dp[1][4][4][1] + dp[1][4][4][3] + 3 =
dp[3][4][4][3] + dp[2][4][4][3] + 1 + 0 + 3 = 
dp[3][4][4][3] + dp[2][4][4][3] + 4 = 
dp[4][4][3][4] + dp[3][4][3][3] + dp[2][4][3][2] + dp[2][4][3][4] + 4 =
dp[4][4][3][4] + dp[3][4][3][3] + 1 + 1 + 4 =
dp[4][4][3][4] + dp[3][4][3][3] + 6 =
0 + dp[4][4][2][4] + dp[3][4][2][4] + 6 =
0 + dp[5][4][1][5] + dp[4][4][1][5] + 1 + 6 =
0 + 0 + 0 + 1 + 6 = 7

